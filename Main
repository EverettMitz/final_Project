    //Draw whole bitmoji
var drawBitmojiMitkowski = function (bodyX, bodyY, bodySize){
    
    var drawHead = function(bodyX, bodyY, bodySize){
        var e = bodySize/100;
        //HOOD
        noStroke();
        fill(33,44,40);
        ellipse(e*75+bodyX,e*83+bodyY,e*50,e*26);
        
        //NECK
        fill(222, 195, 169);//neck color
        ellipse(e*75+bodyX,e*68+bodyY,e*36,e*88);//neck
        
        //HEAD
        fill(255,224,189);//skin tone
        ellipse(e*75+bodyX,e*49+bodyY,e*53,e*52);//head Main
        arc(e*75+bodyX,e*62+bodyY,e*35,e*34,0,180);//chin
    };
    
    var drawGlasses = function(bodyX, bodyY, bodySize){
        var e = bodySize/100;
        
        //GLASSES
        stroke(0, 0, 0);//glasses color
        strokeWeight(e*1.2);//lens thickness
        rect(e*55+bodyX,e*49+bodyY,e*16,e*11,3);//left lens
        rect(e*75+bodyX,e*49+bodyY,e*16,e*11,3);//right lens
        strokeWeight(e*2.7);//wire thickness
        line(e*74+bodyX,e*54+bodyY,e*72+bodyX,e*54+bodyY);//nose thing
        line(e*56+bodyX,e*52+bodyY,e*52+bodyX,e*50+bodyY);//left wire
        line(e*92+bodyX,e*52+bodyY,e*99+bodyX,e*50+bodyY);//right wire
        noStroke();
    };
    
    var drawFace = function(bodyX, bodyY, bodySize){
        var e = bodySize/100;
        //NOSE
        stroke(0, 0, 0);
        strokeWeight(e*0.3);
        bezier(e*72+bodyX,e*60+bodyY,e*82+bodyX,e*60+bodyY,e*75+bodyX,e*67+bodyY,e*71+bodyX,e*64+bodyY);
        noStroke();
        
        //EYES
        fill(0, 40, 92);//eye color
        ellipse(e*64+bodyX,e*55+bodyY,e*6,e*7);//left eye
        ellipse(e*83+bodyX,e*55+bodyY,e*6,e*7);//right eye
        
        //MOUTH
        fill(255, 255, 255);
        stroke(138, 75, 75);//lips?
        strokeWeight(e*1);
        arc(e*74+bodyX,e*67+bodyY,e*17,e*9,0,180);//teeth
        noStroke();
    };
    
    var drawHat= function(bodyX, bodyY, bodySize){
        var e = bodySize/100;
        //HAT
        fill(74, 74, 63);//hat color
        arc(e*75+bodyX,e*35+bodyY,e*53,e*42, -180,0);//hat top
        fill(71,72,64);
        rect(e*49+bodyX,e*46+bodyY,e*53,e*-13);//hat brow
        quad(e*42+bodyX,e*81+bodyY,e*45+bodyX,e*40+bodyY,e*55+bodyX,e*27+bodyY,e*52+bodyX,e*86+bodyY);//hat flap left
        quad(e*106+bodyX,e*84+bodyY,e*103+bodyX,e*38+bodyY,e*93+bodyX,e*28+bodyY,e*97+bodyX,e*87+bodyY);//hat flap left
    };
    
    var drawHoodie = function(bodyX, bodyY, bodySize){
        var e = bodySize/100;
        //HOODIE
        fill(33,44,40);
        ellipse(e*75+bodyX,e*112+bodyY,e*80,e*45);//body
        rect(e*44+bodyX,e*127+bodyY,e*60,e*10);//body
        fill(33,44,40);
        quad(e*93+bodyX,e*77+bodyY,e*58+bodyX,e*98+bodyY,e*121+bodyX,e*98+bodyY,e*96+bodyX,e*83+bodyY);//right shoulder
        quad(e*52+bodyX,e*85+bodyY,e*28+bodyX,e*98+bodyY,e*81+bodyX,e*95+bodyY,e*57+bodyX,e*78+bodyY);//left shoulder
        arc(e*108+bodyX,e*139+bodyY,e*50,e*93,-120,5);//right arm
        arc(e*41+bodyX,e*139+bodyY,e*50,e*93,179,308);//left arm
        fill(0, 0, 0);
        triangle(e*63+bodyX,e*83+bodyY,e*72+bodyX,e*90+bodyY,e*86+bodyX,e*83+bodyY);//shirt
    };
    
    var drawInintials = function(bodyX, bodyY, bodySize){
        var e = bodySize/100;
        //LETTERING
        var font= createFont("cursive");
        fill(255, 255, 255);
        textFont(font, e*10);
        text("E. M.",e*72+bodyX,e*98+bodyY,e*33,e*48);
    
        //Reset lettering
        var font= createFont("sans-serif");
        textFont(font,15);
    
    };
        
        //Draw head
    var drawBitmojiHead = function(bodyX, bodyY, bodySize){
        drawHead(bodyX, bodyY, bodySize);
        drawGlasses(bodyX, bodyY, bodySize);
        drawFace(bodyX, bodyY, bodySize);
        drawHat(bodyX, bodyY, bodySize);
    };
        //Draw Body
    var drawBitmojiBody =function(bodyX, bodyY, bodySize){
        drawHoodie(bodyX, bodyY, bodySize);
        drawInintials(bodyX, bodyY, bodySize);
    };
        drawBitmojiHead(bodyX, bodyY, bodySize);
        drawBitmojiBody(bodyX, bodyY, bodySize);
};
var drawBitmojiAlabede = function(bitmojiX,bitmojiY){
    fill(255, 255, 255); // fill for earring
    stroke(212,175,55); // earring color
    ellipse(bitmojiX-36,bitmojiY+27,30,30); // left earring
    ellipse(bitmojiX+30,bitmojiY+27,30,30); // right earring
    noStroke();
    fill(111,79,29); // fill to skin tone
    ellipse(bitmojiX,bitmojiY,70,86);  //head
    fill(255, 255, 255); // Under scarf color hijab
    ellipse(bitmojiX+1,bitmojiY-30,83,60);  // under scarf
    fill(11, 156, 16); //  Big scarf hijab color
    quad(bitmojiX-77, bitmojiY+50, bitmojiX-37, bitmojiY-32, bitmojiX-13, bitmojiY-49, bitmojiX-46, bitmojiY+50); // left side hijab
    quad(bitmojiX+65, bitmojiY+50, bitmojiX+34, bitmojiY-32, bitmojiX+13, bitmojiY-50, bitmojiX+35, bitmojiY+50); // right side hijab
    ellipse(bitmojiX-1,bitmojiY-32,72,42);  // top scarf
    stroke(0, 0, 0); // stroke to black for glasses
    fill(111,79,29); // fill to skin tone for glasses
    ellipse(bitmojiX-15,bitmojiY+12,18,15); // left glasses
    ellipse(bitmojiX+12,bitmojiY+12,18,15); // right glasses
    line(bitmojiX-6,bitmojiY+12,bitmojiX+2,bitmojiY+12); // glasses nose bridge
    line(bitmojiX+37,bitmojiY+3,bitmojiX+20,bitmojiY+15); // glasses side right
    line(bitmojiX-25,bitmojiY+11,bitmojiX-37,bitmojiY+2); // glasses side left
    fill(0, 0, 0); // black eyes fill
    ellipse(bitmojiX-15,bitmojiY+12,7,7); // left eye
    ellipse(bitmojiX+12,bitmojiY+12,7,7); // right eye
    fill(111,79,29); // fill to skin tone
    bezier(bitmojiX+1,bitmojiY+16,bitmojiX+22,bitmojiY+34,bitmojiX-5,bitmojiY+25,bitmojiX+1,bitmojiY+28); //nose
    fill(111,79,29); // fill to skin tone for lips
    arc(bitmojiX+1, bitmojiY+35, 15, 11, 1, 180); // bottom lips
    arc(bitmojiX+1, bitmojiY+35, 15, -11, 1, 180); // top lip
    line(bitmojiX-6,bitmojiY+35,bitmojiX+8,bitmojiY+35); // line in-between lips
    fill(0, 117, 4); // shirt color 
    rect(bitmojiX-31, bitmojiY+43, 60, 53); // shirt
    fill(111,79,29); // fill to skin tone for shirt-indent
    triangle(bitmojiX-10, bitmojiY+44, bitmojiX+14, bitmojiY+45, bitmojiX+2, bitmojiY+59); // shirt indent
    stroke(255, 255, 255); // letter initial color 
    line(bitmojiX-23,bitmojiY+84,bitmojiX-18,bitmojiY+65); // 1st letter line to the left
    line(bitmojiX-12,bitmojiY+84,bitmojiX-18,bitmojiY+65); // 2nd letter line to the left
    line(bitmojiX-12,bitmojiY+76,bitmojiX-21,bitmojiY+75); // connecting line left
    line(bitmojiX+6,bitmojiY+84,bitmojiX+11,bitmojiY+65); // 1st letter line to the right
    line(bitmojiX+17,bitmojiY+84,bitmojiX+11,bitmojiY+65); // 2nd letter line to the right
    line(bitmojiX+17,bitmojiY+75,bitmojiX+9,bitmojiY+75); // connecting line right
};

var scene = 0;

/*********
  BUTTON
 *********/
var button = function(config) {
    this.x = config.x || 0;
    this.y = config.y || 0;
    this.width = config.width || 150;
    this.height = config.height || 50;
    this.round = config.round || 0;
    this.label = config.label || "Click";
    this.color = config.color || color(255, 255, 255);
    this.onClick = config.onClick || function() {};
};

button.prototype.draw = function() {
    fill(this.color);
    rect(this.x, this.y, this.width, this.height, this.round);
    fill(255, 255, 255);
    textSize(23);
    textAlign(LEFT, TOP);
    text(this.label, this.x+10, this.y+this.height/4);
};

button.prototype.isMouseInside = function() {
    return mouseX > this.x &&
           mouseX < (this.x + this.width) &&
           mouseY > this.y &&
           mouseY < (this.y + this.height);
};

button.prototype.handleMouseClick = function() {
    if (this.isMouseInside()) {
        this.onClick();
    }
};

//SplashScreen Button
var splashBtn = new button(
    {
     x: 70,
     y: 240,
     round: 28,
     label: "         Game Start",
     color: color(0, 191, 255, 90),
     width: 260,
     height: 49,
     onClick: function() {
         scene = 1;
     }
    }
);
//Settings Button
var settingsBtn = new button(
    {
     x: 70,
     y: 298,
     round: 28,
     label: "            Settings",
     color: color(0, 191, 255, 90),
     width: 260,
     height: 49,
     onClick: function() {
         scene = 2;
     }
    }
);

/**************
  KEY TRACKER
 ************/
//to use put Keys[] inside of an if function. It will return true if whatever inside of the brackets matches the corresponding key or keyCode, ei. Keys[UP] for up arrow or keys[32] for space bar. 
//Code for reading multiple simultaneous key presses based partially on Drew Bent's "Multiple Key Presses with Bounces" at https://www.khanacademy.org/computer-programming/multiple-key-presses/977647663

var keys = {}; 

var keyPressed = function() { 
  keys[key.code] = true;
  keys[keyCode] = true;
};
 
var keyReleased = function() { 
  keys[key.code] = false; 
  keys[keyCode] = false;
};

/***********
  SETTINGS
************/
//settings
var steeringType = "mouse";

/***********
    SCENES
************/
                        /**********************
                          SPLASHSCREEN(SCENE O)
                        ************************/
var scene1 = function(){
    background(0, 0, 0);
    
    fill(0, 168, 240, 200);
    textSize(15);
    text("By Everett Mitkowski and Alisha Alabede",67,216);
    textSize(46);
    text("SpaceShip",93,53);    //Couldn't think of a title
    drawBitmojiMitkowski(-2,100,72);
    
    splashBtn.draw();
    settingsBtn.draw();
    
    //Use mouseIsPressed Instead of the mouseClicked function, as mouseClicked function still operates even when scene1 is not called. Gonna say issue with khan, but might be wrong.
    if(mouseIsPressed){
    splashBtn.handleMouseClick();
    settingsBtn.handleMouseClick();
    }

    
};

                        /**********************
                            GAME(SCENE 1)
                        ************************/
                /**********
                   INDEX
                **********/
        /***********************
          !!!GLOBAL VARIABLES!!!
        *************************/
    //Variables to determin ship position
var playerShipX = 200; 
var playerShipY = 200;
    //Variables to determin ship acceleration
var playerShip_Accel_X = 0;
var playerShip_Accel_Y = 0;
    //Variables for the translation of screen to follow the player. 
var translateTileX = 0;
var translateTileY = 0;
    //Variable to describe angle of ship
var playerAngle;
    //Translated mouseX and mouseY (Run translateMouse(); first)
var mouseXT;
var mouseYT;
    //Tile Cordinates
var tilePosX = 0;
var tilePosY = 0;
    //Tile Description
var tileSet = [];
    /* {
            x:
            y:
            stars:
        }; */
//Element of Current Tile in tileSet
var currentTileNum = -1;


        /**********
           TILE
        **********/
//This is where you would add other things to a tile. 
    //Count is number of stars. tileSize is the pixels in either direction. A tileSize       of 200 is a 400*400 large tile.  
var generateTile = function(count, tileSize){
    //Creates the object for a new tile
    var tile = {};
    //Grabs the X and Y cordinated of the tile. This means that global X and Y need to change before the tile is generated
    tile.x = tilePosX;
    tile.y = tilePosY;
    
    tile.size = tileSize;
    
//Generates stars
    //Temporay array to hold stars. Will later be listed under parametes "stars"
    var starsTemp = [];
    
    //Creates all the needed variables for "count" number of stars
    for(var i = 0; i < count; i++){
        starsTemp.push({x:random(-tileSize,tileSize),y:random(-tileSize,tileSize),s:random(1,8),c:color(random(150,255), random(0,250), random(0,50), random(150,255))});
    }
    
    //First sets the list of stars as the paremeter stars under the created tile.
    tile.stars = (starsTemp);
    
    //Pushes the created tile into the global tileSet array. 
    tileSet.push(tile);
};


//Load stars depedning on what tileNum it is 
var loadTile = function(tileNum){
    background(0, 0, 0);
    //Draws a number of ellipses equal to the number of stars as defined by the tile. 
    for(var i = 0; i <tileSet[tileNum].stars.length; i++){
        noStroke();
        fill(tileSet[tileNum].stars[i].c); //grabs color
        ellipse(tileSet[tileNum].stars[i].x, tileSet[tileNum].stars[i].y, tileSet[tileNum].stars[i].s, tileSet[tileNum].stars[i].s); //grabs parameters 
    }
    
    //Temporary Border
    noFill();
    strokeWeight(10);
    stroke(255, 0, 255);
    rect(-tileSet[tileNum].size,-tileSet[tileNum].size,2000,2000);
};

        /****************
          TILE MOVEMENT
        ******************/
var translateMouse = function(){
    mouseXT = mouseX - translateTileX;
    mouseYT = mouseY - translateTileY;
};

var findCurrentTile = function(){
    var cordCheck = function(cord){
        return cord.x === tilePosX && cord.y === tilePosY;
    };
    
    currentTileNum = tileSet.findIndex(cordCheck);
};

//Moves the tile so the ship does not hit the edge of the screen
var moveTile = function(){
        //Move Limits change how close to the edge of the screen player can go
    var moveLimitX = (width/3);
    var moveLimitY = (height/3);
    if(playerShipX + translateTileX < moveLimitX){
        translateTileX -= playerShip_Accel_X;
    }
    if(playerShipX + translateTileX > (width - moveLimitX)){
        translateTileX -= playerShip_Accel_X;
    }
    if(playerShipY + translateTileY < moveLimitY){
        translateTileY -= playerShip_Accel_Y; 
    }
    if(playerShipY + translateTileY > (height - moveLimitY)){
        translateTileY -= playerShip_Accel_Y; 
    }
};

//Changes Cordinates if ship leaves Tile
var tileChange = function(){
    var entryDistance = tileSet[currentTileNum].size*2;
    
    if(playerShipX > tileSet[currentTileNum].size){
        tilePosX += 1;
        translateTileX = translateTileX + entryDistance;
        playerShipX = playerShipX - entryDistance;
    }
    else if(playerShipX < -tileSet[currentTileNum].size){
        tilePosX -= 1;
        translateTileX = translateTileX - entryDistance;
        playerShipX = playerShipX + entryDistance;
    }
    else if(playerShipY < -tileSet[currentTileNum].size){
        tilePosY += 1;
        translateTileY = translateTileY - entryDistance;
        playerShipY = playerShipY + entryDistance;
    }
    else if(playerShipY > tileSet[currentTileNum].size){
        tilePosY -= 1;
        translateTileY = translateTileY + entryDistance;
        playerShipY = playerShipY - entryDistance;
    }
};
        /****************
        STEERING/MOVEMENT
        ******************/
var mouseControl = function(){    
        //Distance of ship from Mouse. Total, Y-axis, X-axis. 
    var distance = sqrt(pow(mouseXT-playerShipX,2)+pow(mouseYT-playerShipY,2));//Total distance
    var distanceY = playerShipY-mouseYT;// Distance of ship on the Y axis
    var distanceX = mouseXT-playerShipX;// Distance of ship on the X axis

    var PlayerSpeed = 20; //higher = slower
    var PlayerAcceleration = 0.4;
    var PlayerFriction = 0.95; //higher = less Friction
    
        //Adjusts acceleration depending on distance from mouse
    //Acceleration controlls for X
    if(keyIsPressed && keys[32]){
        if (distanceX > 0){
            playerShip_Accel_X = playerShip_Accel_X + (pow(abs(distanceX), (PlayerAcceleration))/PlayerSpeed);
        }
        else if (distanceX < 0){
            playerShip_Accel_X = playerShip_Accel_X - (pow(abs(distanceX), (PlayerAcceleration))/PlayerSpeed);
        }
        //Acceleration controlls for Y
        if (distanceY > 0){
            playerShip_Accel_Y = playerShip_Accel_Y - (pow(abs(distanceY), (PlayerAcceleration))/PlayerSpeed);
        }
        else if (distanceY < 0){
            playerShip_Accel_Y = playerShip_Accel_Y + (pow(abs(distanceY), (PlayerAcceleration))/PlayerSpeed);
        }
    }
        
    //Deceleration
    playerShip_Accel_Y = playerShip_Accel_Y*PlayerFriction;
    playerShip_Accel_X = playerShip_Accel_X*PlayerFriction;
};

        /****************
         SHIP PARAMETERS 
        ******************/

//calculates the angle between ship and mouse. Sets "angle" equal to this.

//Contains trainslation and rotation to matrix. This means anything outside of the matric is not effected by the angle nor the translation.
var drawShip = function(){
    //Change this For size
    var spaceShipSize = 45;
    var s = spaceShipSize/100;
    
    if(steeringType === "mouse"){
        playerAngle = (atan2(mouseYT - playerShipY,mouseXT-playerShipX));
    }
    pushMatrix();
        
        translate(playerShipX,playerShipY); //Changes X & Y
        rotate(playerAngle);
        
        noStroke(); //SpaceShip
        fill(135, 135, 135);
        triangle(s*-20,s*20,s*-20,s*-20,s*35,s*0);
        
    popMatrix();
};
        /****************
            SPACE CODE 
        ******************/
var exploreSpace = function (){
    var tileNotGenerated = function(){
        return currentTileNum === -1;
    };
    
    findCurrentTile(); //Find tile element number
    
    if (tileNotGenerated()){
        generateTile(1000,1000); //Generates Tile if does not exist
    }
    
    if (!tileNotGenerated()){
        tileChange();//checks to see if ship has left tile
        translateMouse();//Translates mouse 
        moveTile();//Modifies translateTile X and Y in the code below
        pushMatrix();
        translate(translateTileX,translateTileY);
            loadTile(currentTileNum); //Draws Stars
        //set steering type to mouse
        if(steeringType === "mouse"){
        mouseControl(); //Adjusts acceleration and rotation according to mouse position
        }
        
        //Moves ship based on values described by mouseControl
        playerShipY = playerShipY + playerShip_Accel_Y;
        playerShipX = playerShipX + playerShip_Accel_X;
        
        drawShip();
        
        popMatrix();//matrix right under follow is declared
    }
    /*************
        DEBUG
    *************/
    //println("("+tilePosY+" , " + tilePosX + ")");
    // println("y:" + distanceY + "  x:" + distanceX + "  XY:" + round(distance));
    //println("y:" + playerShip_Accel_Y + "  x:" + playerShip_Accel_X);
    //println("PlayerX: " + round(playerShipX) + "  PlayerY: " + round(playerShipY));
};
    
                /***************
                    RUN GAME
                ***************/
var scene2 = function(){
    exploreSpace();
};

                        /**********************
                          SETTINGS (SCENE 2)
                        ************************/
var scene3 = function(){
    background(0, 0, 0);
    fill(255, 0, 0);
    text("Controls are just space for thrust at the moment. Real settings (like mouse and key movemnt) in the future. For now this is mostly a placeholder",20,20,380,400);
};

/****************
  SCENE SELECT
*****************/
draw = function() {
    if (scene === 0){
        scene1();
    } 
    else if (scene === 1){
        scene2();
    }
    else if (scene === 2){
        scene3();
    }
};

